<!DOCTYPE html>

<html>

<head>
	<title>The group_by Method</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<link type="text/css" rel="stylesheet" href="../stylesheets/default.css">
	<link type="text/css" rel="stylesheet" href="../stylesheets/blog-stylesheet.css">
</head>

<body>

<!-- Image, name and title area -->
<header>
	<img src="../imgs/jeremy_gagon.jpg" alt="Headshot Jeremy Gagon" />
	<section>
		<h1>Jeremy Gagon</h1>
		<h2>Web Developer</h2>
	</section>
	<!-- Quote section -->
	<section id="quote">
		<h3 class="invisible">Quote</h3>
		<q>I want to put a ding in the universe.</q>
		<p>Steve Jobs</p>
	</section>
	<!-- Primary Navigation Section -->
	<nav>
		<ul>
  			<li><a href="../index.html">Home</a></li>
			<li class="line"><a href="#">Portfolio</a></li>
			<li class="line"><a href="index.html" id="current" >Blog</a></li>
			<li class="line"><a href="#">About Me</a></li>
			<li class="line"><a href="#">Contact</a></li>
		</ul>
	</nav>

</header>

<!-- Main content area -->
<main>
	<section id="blog">
		<h1>The group_by Method</h1>
		<h2>Mixin It Up!</h2>
		<h3>December 14, 2014</h3>
		<p>Welcome back to my blog!
		</p>
		<p>This week I am looking at the Ruby <code>group_by</code> method of the Enumerable module.
		</p>
		<p>In case you don't know what an Enumerable module is:
		</p>
		<p>In Ruby, a class definition is where we provide the blueprint for an object. We then create an object from that class by instantiating a new instance of the class.
		</p>
		<p>In our class definition, we teach our object how to do stuff by defining methods that we can then ask our object to do.
		</p>
		<p>Sometimes dissimilar classes of objects have similar methods: you could have a <code>set_sale_price</code> method for a car object and a frying pan object. These objects would not come from the same inherited class, but could benefit from use of the same method. That's where modules come in.
		</p>
		<p>A module provides a set of common methods or functions that can be added or <q>Mixed in</q> to a class definition. The objects instantiated from that class can then use those methods.
		</p>
		<p>The Enumerable module provides a set of methods to deal with collections of data like arrays and hashes. Using Enumerable methods, you can iterate through a collection of data and do things with some or all of the elements of that data.
		</p>
		<p>The <code>group_by</code> method is one of the perhaps lesser-known Enumerable methods. However, it does interesting things and can be very useful in the right context.
		</p>
		<p>The <code>group_by</code> method allows you to iterate through a set of data and group the contents of the data according to a block of code that you pass in.
		</p>
		<p>The returned object is a hash where each hash key represents a category of the sorted data. The hash value is a nested array containing all of the elements from the original array or hash that meet the criteria.
		</p>
		<p>Let's look at an array example: I will take an array of numbers and organize them into groups of those that are evenly divisible by 2 and those that are not.
		</p>
		<pre><code>
my_number_array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  #my initial array

my_number_array.group_by { |x| x % 2 == 0 }  #call group_by method to find numbers evenly divisible by 2

=> {false=>[1, 3, 5, 7, 9], true=>[2, 4, 6, 8, 10]}  #returned hash sorting data into groups
		</code></pre>
		<p>In this case, the keys are boolean categories of evenly divisible by 2 (true) and not evenly divisible by two (false).
		</p>
		<p>It's actually really handy! If you capture the returned hash in a variable, you have access to the sorted data set for future processing.
		</p>
		<p>What happens when you call group_by on a hash?
		</p>
		<p>When you call group_by on a hash, you are also returned a new hash. The hash contains keys that represent the categories. Like arrays, the value for each key is a nested array. Due to the structure of hashes, the nested arrays that serve as the hash values contain other nested arrays for each key-value pair from the original hash that satisfy the criteria.
		</p>
		<p>Here's a hash example. Let's figure out which values are strings and which are not:
		</p>
		<pre><code>
my_hash = {:first_name => "Jeremy", :last_name => "Gagon", :age => 21}  #Cool, I can drink now!

my_hash.group_by {|k,v| v.is_a? String}

=> {true=>[[:first_name, "Jeremy"], [:last_name, "Gagon"]], false=>[[:age, 21]]}
		</code></pre>
		<p>Like with all Enumerable methods, as you use it more, you understand the context in which it is most effective. I will definitely keep this method in mind as I'm tackling new problems with Ruby data collections.
		</p>

	</section>
</main>
<!-- sidebar area -->
<aside>
	<!-- Twitter widget -->
	<a class="twitter-timeline" href="https://twitter.com/jergagon1" data-widget-id="538848438926843904">Tweets by @jergagon1</a>
	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
</aside>

<!-- Secondary Navigation to external links -->
<footer>
	<ul>
		<li><a href="mailto:jergagon1@gmail.com">Email</a></li>
		<li class="line"><a href="https://github.com/jergagon1">GitHub</a></li>
		<li class="line"><a href="https://www.facebook.com/jeremygagon">Facebook</a></li>
		<li class="line"><a href="https://twitter.com/jergagon1">Twitter</a></li>
		<li class="line"><a href="http://www.quora.com/Jeremy-Gagon">Quora</a></li>
		<li class="line"><a href="http://www.linkedin.com/pub/jeremy-gagon/30/750/285/">Linkedin</a></li>
	</ul>
</footer>

</body>

</html>